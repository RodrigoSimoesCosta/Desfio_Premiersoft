# -*- coding: utf-8 -*-
"""Desafio_Premier_Soft.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KG-8LjO9fIUAEN32NlCzYKN-4yCrobDo

# Bibliotecas
"""

import keras
import tensorflow as tf

print("Keras version:", keras.__version__)
print("TensorFlow version:", tf.__version__)

import os
import numpy as np
import tensorflow as tf

from PIL import Image
import matplotlib.pyplot as plt

import torch
import cv2

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Flatten
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing import image
from tensorflow.keras import layers, models

"""# 1- Montando o drive"""

from google.colab import drive
drive.mount('/content/drive')

#!pip install -r /content/drive/MyDrive/PremierSoft_desafio/requirements.txt

"""# 2- Pegando os dados"""

# Definir o caminho para o arquivo .zip
zip_path = '/content/drive/MyDrive/PremierSoft_desafio/dataset_openclose.zip'

## Descompactar o arquivo .zip
import zipfile

## Caminho para a pasta onde você quer descompactar
extract_path = '/content/drive/MyDrive/PremierSoft_desafio/'

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print("Arquivos descompactados.")

# Ler as imagens descompactadas
# Listar os arquivos descompactados
image_path = '/content/drive/MyDrive/PremierSoft_desafio/dataset_openclose'
image_files = [f for f in os.listdir(image_path) if f.endswith(('.png', '.jpg', '.jpeg'))]

# Total de imagens
len(image_files)

# Exibir uma imagem
if image_files:
    img_path = os.path.join(image_path, image_files[8300])
    img = Image.open(img_path)
    plt.imshow(img)
    plt.axis('off')  # Ocultar o eixo
    plt.show()
else:
    print("Nenhuma imagem encontrada no arquivo .zip.")

"""# 3- Separando algumas imagens para novas pastas (aberta e fechada)"""

import shutil

# Caminho da pasta original onde as imagens estão localizadas
image_path = "/content/drive/MyDrive/PremierSoft_desafio/dataset_openclose"
image_files = os.listdir(image_path)

# Seleção das imagens aberta e fechada
# Intervalo de arquivos de imagem selecionadas
selected_images_fechada = image_files[8000:8500]
# Intervalo de arquivos de imagem selecionadas
selected_images_aberta = image_files[0:500]

# Pasta onde as imagens selecionadas serão copiadas
image_path_novo = '/content/drive/MyDrive/PremierSoft_desafio/desafio'
# Imagens aberta
img_path_aberta = os.path.join(image_path_novo, "img_path_aberta")
os.makedirs(img_path_aberta, exist_ok=True)
# Imagens fechada
img_path_fechada = os.path.join(image_path_novo, "img_path_fechada")
os.makedirs(img_path_fechada, exist_ok=True)

print(len(image_files))
print(len(selected_images_fechada))
print(len(selected_images_aberta))

"""## 3.1- Imagens Abertas"""

# Copiar os arquivos selecionados para a nova pasta
for image_file in selected_images_aberta:
    source = os.path.join(image_path, image_file)
    destination = os.path.join(img_path_aberta, image_file)

    # Verifica se o arquivo é uma imagem
    if os.path.isfile(source):
        shutil.copy(source, destination)

print(f"As imagens foram copiadas para: {img_path_aberta}")

# Definir as extensões de imagens que queremos contar
extensoes_imagens = ['.jpg', '.jpeg', '.png']
# Listar os arquivos na pasta e filtrar pelas imagens
imagens_aberta = [f for f in os.listdir(img_path_aberta) if os.path.splitext(f)[1].lower() in extensoes_imagens]
# Quantidade de imagens
quantidade_imagens_aberta = len(imagens_aberta)

print(f'Número de imagens na pasta img_path_aberta: {quantidade_imagens_aberta}')

"""## 3.2- Imagens Fechadas"""

# Copiar os arquivos selecionados para a nova pasta
for image_file in selected_images_fechada:
    source = os.path.join(image_path, image_file)
    destination = os.path.join(img_path_fechada, image_file)

    # Verifica se o arquivo é uma imagem
    if os.path.isfile(source):
        shutil.copy(source, destination)

print(f"As imagens foram copiadas para: {img_path_fechada}")

# Definir as extensões de imagens que queremos contar
extensoes_imagens = ['.jpg', '.jpeg', '.png']
# Listar os arquivos na pasta e filtrar pelas imagens
imagens_fechada = [f for f in os.listdir(img_path_fechada) if os.path.splitext(f)[1].lower() in extensoes_imagens]
# Quantidade de imagens
quantidade_imagens_fechada = len(imagens_fechada)

print(f'Número de imagens na pasta img_path_aberta: {quantidade_imagens_fechada}')

"""# 4- Pré-processamento das imagens

## 4.1- Padronizando a dimensão das imagens
"""

# Pré-processamento das imagens
# Redimensionar as imagens para 224x224 pixels
img_height = 224
img_width = 224
batch_size = 32 # Número de imagens que serão carregadas e processadas em cada iteração do treinamento (32 imagens por vez)

"""## 4.2- Gerando novas imagens de treinamento, rotacionadas e com zoom aleatórios"""

# Geradores de dados (com aumento de dados)
train_datagen = ImageDataGenerator(
    rescale=1./255,#Reduz o valor dos pixels das imagens para o intervalo entre 0 e 1
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,#Aplica uma transformação de cisalhamento (shear) nas imagens (distorcendo a imagem de forma)
    zoom_range=0.2,#Aplica um aumento aleatório de zoom nas imagens, variando de acordo com a porcentagem indicada (20%)
    horizontal_flip=True,#Realiza um flip horizontal nas imagens de maneira aleatória (criando imagens espelhadas)
    fill_mode='nearest')

train_generator = train_datagen.flow_from_directory(
    '/content/drive/MyDrive/PremierSoft_desafio/desafio',
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='binary'
)

"""# 5- Criando o algoritmo"""

# Definindo o caminho para os diretórios de imagens
path_aberta = '/content/drive/MyDrive/PremierSoft_desafio/desafio/img_path_aberta'
path_fechada = '/content/drive/MyDrive/PremierSoft_desafio/desafio/img_path_fechada'

# Definindo o modelo de CNN
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

# Compilando o modelo
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Treinando o modelo
model.fit(train_generator, epochs=10)

# Salvando o modelo em um arquivo H5
model.save('/content/drive/MyDrive/PremierSoft_desafio/garrafa_model.h5')
# Salvando o modelo no formato .keras
model.save('/content/drive/MyDrive/PremierSoft_desafio/garrafa_model.keras')
# Salvando o modelo no formato .keras
#from tensorflow.keras.models import load_model
#model = load_model('/content/drive/MyDrive/PremierSoft_desafio/garrafa_model.h5')